generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

<<<<<<< HEAD
model customer_order_product {
  id              String         @id @default(uuid())
  customerOrderId String
  productId       String
  quantity        Int
  customerOrder   customer_order @relation(fields: [customerOrderId], references: [id])
  product         product        @relation(fields: [productId], references: [id])

  @@index([customerOrderId], map: "customer_order_product_customerOrderId_fkey")
  @@index([productId], map: "customer_order_product_productId_fkey")

}

model category {
  id      String    @id @default(uuid())
  name    String    @unique(map: "Category_name_key")
  product product[]
}

<<<<<<< HEAD
model customer_order {
=======
model User {
  id            String         @id @default(uuid())
  email         String         @unique
  password      String?
  role          String?        @default("user")
  Wishlist      Wishlist[]
  notifications Notification[]
}

model Customer_order {
>>>>>>> a89075feae2df4122e816472412706b5aad17a94
  id          String                   @id @default(uuid())
  name        String
  lastname    String
  phone       String
  email       String
  company     String
  adress      String
  apartment   String
  postalCode  String
  dateTime    DateTime?                @default(now())
  status      String
  city        String
  country     String
  orderNotice String?
  total       Int
  products    customer_order_product[]
}

model image {
  imageID   String @id
  productID String
  image     String
}

model merchant {
  id          String    @id @default(uuid())
  name        String
  description String?
  email       String?
  phone       String?
  address     String?
  status      String    @default("ACTIVE")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  product     product[]
}

model notification {
  id        String                @id
  userId    String
<<<<<<< HEAD
  title     String
  message   String                @db.Text
  type      notification_type
  isRead    Boolean               @default(false)
  priority  notification_priority @default(NORMAL)
  metadata  String?               @db.LongText
  createdAt DateTime              @default(now())
  updatedAt DateTime
  user      user                  @relation(fields: [userId], references: [id], onDelete: Cascade, map: "Notification_userId_fkey")
=======
}
>>>>>>> a89075feae2df4122e816472412706b5aad17a94

  @@index([createdAt], map: "Notification_createdAt_idx")
  @@index([userId], map: "Notification_userId_idx")
  @@index([userId, isRead], map: "Notification_userId_isRead_idx")
  @@index([userId, type], map: "Notification_userId_type_idx")
}

model product {
  id             String                   @id
  slug           String                   @unique(map: "Product_slug_key")
  title          String
  mainImage      String
  price          Int                      @default(0)
  rating         Int                      @default(0)
  description    String
  manufacturer   String
  inStock        Int                      @default(1)
  categoryId     String
  merchantId     String
  customerOrders customer_order_product[]
  category       category                 @relation(fields: [categoryId], references: [id], onDelete: Cascade, map: "Product_categoryId_fkey")
  merchant       merchant                 @relation(fields: [merchantId], references: [id], map: "Product_merchantId_fkey")
  wishlist       wishlist[]

  @@index([categoryId], map: "Product_categoryId_fkey")
  @@index([merchantId], map: "Product_merchantId_fkey")
}

model user {
  id           String         @id
  email        String         @unique(map: "User_email_key")
  password     String?
  role         String?        @default("user")
  notification notification[]
  wishlist     wishlist[]

  wallet wallet? // <-- Added opposite relation for wallet
}

model wishlist {
  id        String  @id
  productId String
  userId    String
  product   product @relation(fields: [productId], references: [id], onDelete: Cascade, map: "Wishlist_productId_fkey")
  user      user    @relation(fields: [userId], references: [id], onDelete: Cascade, map: "Wishlist_userId_fkey")

  @@index([productId], map: "Wishlist_productId_fkey")
  @@index([userId], map: "Wishlist_userId_fkey")
}

enum notification_type {
  ORDER_UPDATE
  PAYMENT_STATUS
  PROMOTION
  SYSTEM_ALERT
}

enum notification_priority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model wallet {
  id        String   @id @default(uuid())
  userId    String   @unique
  user      user     @relation(fields: [userId], references: [id], onDelete: Cascade)
  balance   Int      @default(0)
  currency  String   @default("INR")
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactions walletTransaction[]
}

model walletTransaction {
  id          String             @id @default(uuid())
  walletId    String
  wallet      wallet             @relation(fields: [walletId], references: [id], onDelete: Cascade)
  amount      Int
  type        transaction_type
  status      transaction_status @default(PENDING)
  description String?
  reference   String?
  metadata    Json?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([walletId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
}

enum transaction_type {
  CREDIT
  DEBIT
  REFUND
  PAYMENT
  TRANSFER
}
<<<<<<< HEAD

enum transaction_status {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}


=======
>>>>>>> a89075feae2df4122e816472412706b5aad17a94
